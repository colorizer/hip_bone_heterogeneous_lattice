module gen_ltc_msh

include("./msh_frm_binvox.jl")
import Main.msh_frm_binvox: mesh_from_binvox
export generate_lattice, generate_t_matrices
using DataFrames
using SparseArrays
using LinearAlgebra

function generate_node_coord(elem_nodes, coords, ratio::Float64=0.5)
    start = coords[:,elem_nodes[1,:]];
    stop = coords[:, elem_nodes[2,:]];

    return start .+ ratio.*(stop .- start)
end

gmsh_hexahedron = ( # The matrices are transposed. Each row actually is a column.
    face_nodes =   [1 2 3 4;  #uv plane (Back)
                    5 6 7 8;  #uv plane (Front)
                    1 5 8 4;  #vw plane (Left)
                    2 6 7 3;  #vw plane (Right)
                    1 5 6 2;  #uw plane (Bottom)
                    4 8 7 3]',#uw plane (Top)
    edge_nodes =   [1 2; # parallel to u
                    4 3;
                    5 6;
                    8 7;
                    1 4; # parallel to v
                    5 8;
                    2 3;
                    6 7;
                    1 5; # parallel to w
                    4 8;
                    2 6;
                    3 7]',
    edges_in_face =    [1 2; #bottom
                        4 3; #top
                        1 4; #left
                        2 3;]' #right
)

function find_Vᵤ(cell_vertices, nodeCoords, edge_nodes)
    xᵢ = edge_nodes[:, 1];
    yᵢ = edge_nodes[:, 5];
    zᵢ = edge_nodes[:, 9];
    lx = norm(diff(nodeCoords[:, cell_vertices[xᵢ]], dims=2));
    ly = norm(diff(nodeCoords[:, cell_vertices[yᵢ]], dims=2));
    lz = norm(diff(nodeCoords[:, cell_vertices[zᵢ]], dims=2));
    return lx*ly*lz
end

function generate_unique_map(item_arr, cell_id_arr, N_CELLS)
    df = DataFrame(:item=>collect(eachcol(item_arr)), :cell_id=>cell_id_arr);
    df = combine(groupby(df, :item), :cell_id=> Ref => :cell_ids, nrow => :count);
    redundancy = df[!, :count];
    N_ITEMS = size(df, 1);
    cell_item_map = falses((N_CELLS, N_ITEMS));
    for i in 1:N_ITEMS
        cell_item_map[df[i, :cell_ids], i] .= true;
    end
    unique_items = hcat(df[!, :item]...);
    return (N_ITEMS, unique_items, sparse(cell_item_map), redundancy)

end

function find_indices(arr, unique_arr)
    return indexin(collect(eachcol(arr)), collect(eachcol(unique_arr)))
end

function assign_cell_connections(start, stop, mapping, indices)
    r = start:stop;
    nz_indices = findnz(mapping[:, indices])[1:2]
    return [nz_indices[1] r[nz_indices[2]]]
end

function generate_lattice(filename)
    """
    The input is an gmsh ".msh" file with voxels converted into hexahedral elements. The gmsh hexahedrons have a certain order for the nodes. This knowledge is used to generate the lattice structure.

    The generation of lattice structure is divided into three steps.

    TOTAL NUMBER OF CONNECTIVITIES
    --------------------------
    1. EDGES
    -> 2 per edge

    2. FACES
    FE -> 4
    EE -> 4*2 = 8
    VF -> 4*2 = 8
    -> 20 per face

    3. cell
    BV -> 8
    BE -> 12*2 = 24
    BF -> 6
    FF -> 12*2 = 24
    -> 62 per cell.
    --------------------------
    The data we need are:
    1. connectivity (which 2 nodes are connected)
    2. cell -> phase -> connectivity map (which cells and phase each connectivity belong. This needs to be in such a way that we can associate density with each one)
    3. redundancy of each connection. Basically, how many cells share the connections.
    4. Boundary nodes. This can be achieved in a neat way.
        i) Nodes on edges should not be shared between more than 3 cells.
        ii) Nodes on Face should not be shared (only one cell it should belong to).
        iii) Nodes inside body are not boundary nodes.
    5. Length of each connection. This is easy since the length of all connections in a phase is same. Hence a simple dictionary should do!
    6.


    In order to generate each of them, the link between each lattice (cell) and the corresponding edges and faces are required. With this data, the ... (to be filled).
    """

    cell_id, cell_vertice_ids, node_ids, nodeCoords = mesh_from_binvox(filename);

    N_VERTICES = 8;
    N_FACES = 6;
    N_EDGES = 12;
    N_VERTICES_TOTAL = length(node_ids);
    N_CELLS_TOTAL = length(cell_id);
    N_NODES = length(node_ids);
    N_PHASES = 8;

    # Step 1 => Generate the list of faces and the corresponding list of cell ids

    # face nodes as per the hexahedrons generated by gmsh.
    face_nodes = gmsh_hexahedron.face_nodes;

    cell_faces = reshape(cell_vertice_ids[face_nodes,:], size(face_nodes,1), N_CELLS_TOTAL*N_FACES);
    cell_id_face = repeat(cell_id, inner=N_FACES);

    # Step 1.2 => Get the list of cell ids per face
    N_FACES_TOTAL, cell_faces_unique, cell_faces_map, face_redundancy = generate_unique_map(cell_faces, cell_id_face, N_CELLS_TOTAL);
    cell_faces_indices = find_indices(cell_faces, cell_faces_unique);
    println("1. Generated the list of cell ids per unique face")
    # Step 2 => Generate the list of edges and the corresponding list of cell ids

    #edge nodes as per the hexahedrons generated by gmsh
    edge_nodes = gmsh_hexahedron.edge_nodes;

    cell_edges = reshape(cell_vertice_ids[edge_nodes, :], size(edge_nodes, 1), N_CELLS_TOTAL*N_EDGES);
    cell_id_edges = repeat(cell_id, inner=N_EDGES);

    # Step 2.2 => Get the list of cell ids per edge
    N_EDGES_TOTAL, cell_edges_unique, cell_edges_map, edge_redundancy = generate_unique_map(cell_edges, cell_id_edges, N_CELLS_TOTAL);
    cell_edges_indices = find_indices(cell_edges, cell_edges_unique);
    println("2. Generated the list of cell ids per unique edge")

    # Step 3 => Generate the mid nodes for the edges.
    nodeCoords_edge_centers = generate_node_coord(cell_edges_unique, nodeCoords, 0.5);
    nodeCoords2 = hcat(nodeCoords, nodeCoords_edge_centers);
    N_NODES2 = N_NODES + N_EDGES_TOTAL;

    node_ids_edge_centers = N_NODES+1:N_NODES2;
    node_ids2 = vcat(node_ids, node_ids_edge_centers);
    println("3. Mid nodes generated for the edges")

    # Initiate the connectivities and the related matrices.
    phases = Dict(:VE=>1, :FE=>2, :VF=>3, :EE=>4, :BV=>5, :BF=>6, :BE=>7, :FF=>8);

    #As seen in the comment in start of the functions, total number of connectivities
    N_CONNECTIONS = N_EDGES_TOTAL*2 + N_FACES_TOTAL*20 + N_CELLS_TOTAL*62;
    connectivities = zeros(Int, N_CONNECTIONS, 2);
    redundancy = zeros(UInt8, N_CONNECTIONS);
    connectivities_phase_id = zeros(Int8, N_CONNECTIONS);

    # Step 5 => Generate the connectivity for VE
    connectivities[1:N_EDGES_TOTAL, :] = hcat(cell_edges_unique[1,:], node_ids_edge_centers);
    connectivities[N_EDGES_TOTAL+1:N_EDGES_TOTAL*2, :] = hcat(node_ids_edge_centers, cell_edges_unique[2,:]);
    redundancy[1:N_EDGES_TOTAL*2] = repeat(edge_redundancy, outer=2);
    connectivities_phase_id[1:N_EDGES_TOTAL*2] .= phases[:VE];
    println("5. Connections for Vertices-Edge Centers (VE) generated")

    # Step 6 => Generate the face centers
    # idea is to take two corners of the face and find their midpoints.
    nodeCoords_face_centers = generate_node_coord(cell_faces_unique[[1,3],:], nodeCoords, 0.5);
    N_NODES3 = N_NODES2 + N_FACES_TOTAL;
    node_ids_face_centers = N_NODES2+1:N_NODES3;
    node_ids3 = vcat(node_ids2, node_ids_face_centers);
    nodeCoords3 = hcat(nodeCoords2, nodeCoords_face_centers);
    println("6. Generated face centers")

    # Step 7 => Generate FE connections
    edges_in_face = gmsh_hexahedron.edges_in_face;
    face_edges = reshape(cell_faces_unique[edges_in_face,:], 2, :);
    face_edges_indices = find_indices(face_edges, cell_edges_unique);
    node_ids_face_edge_centers = node_ids_edge_centers[face_edges_indices]; # every 4 node ids correspond to the edge centers of 1 face.
    node_ids_face_centers_repeated4 = repeat(node_ids_face_centers, inner=size(edges_in_face, 2))
    face_redundancy_repeated4 = repeat(face_redundancy, inner=size(edges_in_face,2))

    # Generate the connections between face centers and edge centers.
    connectivities[N_EDGES_TOTAL*2+1:N_EDGES_TOTAL*2+N_FACES_TOTAL*4, :] = hcat(node_ids_face_centers_repeated4, node_ids_face_edge_centers);
    redundancy[N_EDGES_TOTAL*2+1:N_EDGES_TOTAL*2+N_FACES_TOTAL*4] = face_redundancy_repeated4;
    connectivities_phase_id[N_EDGES_TOTAL*2+1:N_EDGES_TOTAL*2+N_FACES_TOTAL*4] .= phases[:FE];

    println("7. Face centers - Edge centers connections generated")

    # Step 8 => Generate all the mid nodes in a face.
    """
    The step to generate mid nodes is as follows:
        1. get a list of all vertices in a face (each 4 vertices correspond to 1 face).
        2. Repeat the face center node ids 4 times.
        3. Using the updated nodalCoords to generate the nodal coordinates using the above node ids.

    """
    nodeCoords_face_midnodes = generate_node_coord([reshape(cell_faces_unique,:) node_ids_face_centers_repeated4]', nodeCoords3, 0.5);
    N_FACE_MIDNODES_TOTAL = N_FACES_TOTAL*4;
    N_NODES4 = N_NODES3 + N_FACE_MIDNODES_TOTAL;
    node_ids_face_midnodes = N_NODES3+1:N_NODES4;
    node_ids4 = [node_ids3; node_ids_face_midnodes];
    nodeCoords4 = [nodeCoords3 nodeCoords_face_midnodes];

    println("8. Face midnodes generated")

    # Step 9 => Generate VF connections
    # The face midnodes occur in the same order as vertices. Therefore, the connections are straightforward. v->M and M->F.
    connectivities[2*N_EDGES_TOTAL+4*N_FACES_TOTAL+1:2*N_EDGES_TOTAL+8*N_FACES_TOTAL, :] = [reshape(cell_faces_unique,:) node_ids_face_midnodes];
    connectivities[2*N_EDGES_TOTAL+8*N_FACES_TOTAL+1:2*N_EDGES_TOTAL+12*N_FACES_TOTAL, :] = [node_ids_face_midnodes node_ids_face_centers_repeated4];
    redundancy[2*N_EDGES_TOTAL+4*N_FACES_TOTAL+1:2*N_EDGES_TOTAL+12*N_FACES_TOTAL] = repeat(face_redundancy_repeated4, outer=2);
    connectivities_phase_id[2*N_EDGES_TOTAL+4*N_FACES_TOTAL+1:2*N_EDGES_TOTAL+12*N_FACES_TOTAL] .= phases[:VF];
    println("9. Vertices => face midnodes => face centers connections generated")

    # Step 10 => Generate EE connections
    """
    Edge centers occur in the order of the edges in the variable "face_edge_centers". We know that the edges are taken in the following order in the face:
        edges_in_face = np.array([[1,2], #bottom 1
                                [4,3], #top    2
                                [1,4], #left   3
                                [2,3]]) #right 4
    The mid nodes in the variable "node_id_face_midnodes" occur in the order of the vertices which occur in the following order:
        1 -> bottom left
        2 -> bottom right
        3 -> top right
        4 -> top left.

    Therefore, the E-M-E connection should occur in the following order:
    ╔════════╦═══════╦═══╦═══╦═══╗
    ║ Start  ║ End   ║ E ║ M ║ E ║
    ╠════════╬═══════╬═══╬═══╬═══╣
    ║ Bottom ║ Left  ║ 1 ║ 1 ║ 3 ║
    ╠════════╬═══════╬═══╬═══╬═══╣
    ║ Bottom ║ Right ║ 1 ║ 2 ║ 4 ║
    ╠════════╬═══════╬═══╬═══╬═══╣
    ║ Top    ║ Right ║ 2 ║ 3 ║ 4 ║
    ╠════════╬═══════╬═══╬═══╬═══╣
    ║ Top    ║ Left  ║ 2 ║ 4 ║ 3 ║
    ╚════════╩═══════╩═══╩═══╩═══╝
    """
    # EM connections
    connectivities[2*N_EDGES_TOTAL+12*N_FACES_TOTAL+1:2*N_EDGES_TOTAL+16*N_FACES_TOTAL, :] = [reshape(reshape(node_ids_face_edge_centers,4,:)[[1,1,2,2],:],:) node_ids_face_midnodes];
    connectivities[2*N_EDGES_TOTAL+16*N_FACES_TOTAL+1:2*N_EDGES_TOTAL+20*N_FACES_TOTAL, :] = [node_ids_face_midnodes reshape(reshape(node_ids_face_edge_centers,4,:)[[3,4,4,3],:],:)];

    # Redundancy of EE connections is same as redundancy of the corresponding face.
    redundancy[2*N_EDGES_TOTAL+12*N_FACES_TOTAL+1:2*N_EDGES_TOTAL+16*N_FACES_TOTAL] = face_redundancy_repeated4;
    redundancy[2*N_EDGES_TOTAL+16*N_FACES_TOTAL+1:2*N_EDGES_TOTAL+20*N_FACES_TOTAL] = face_redundancy_repeated4;
    connectivities_phase_id[2*N_EDGES_TOTAL+12*N_FACES_TOTAL+1:2*N_EDGES_TOTAL+20*N_FACES_TOTAL] .= phases[:EE];
    println("10. Edge centers => face midnodes => Edge centers connections have been generated")
    println("*****All the face connections have been generated******")
    CONNECTIONS_COUNT_FACES = 2*N_EDGES_TOTAL+20*N_FACES_TOTAL;
    # ----------------FACE NODES DONE---------------------#
    #=
    Remaining Connectivities:
        **cell**
        BV -> 8
        BE -> 12*2 = 24
        BF -> 6
        FF -> 12*2 = 24
        -> 62 per cell.
    =#

    # Step 11 => Generate body centers for all cells.
    # The body center occurs at the mid of 1 & 7 nodes.
    nodeCoords_body_centers = generate_node_coord(cell_vertice_ids[[1,7],:], nodeCoords)
    N_NODES5 = N_NODES4 + N_CELLS_TOTAL;
    node_ids_body_centers = N_NODES4+1:N_NODES5;
    node_ids5 = [node_ids4; node_ids_body_centers];
    nodeCoords5 = [nodeCoords4 nodeCoords_body_centers];
    println("11. Generated body centers")

    # Step 12 => Generate the BV connections
    #=
    This connection is simple:
        1. Repeat the body center node ids 8 times.
        2. reshape cell_vertices and then add to connectivities.
    =#
    connectivities[CONNECTIONS_COUNT_FACES+1:CONNECTIONS_COUNT_FACES+8*N_CELLS_TOTAL, :] = [repeat(node_ids_body_centers, inner=N_VERTICES) reshape(cell_vertice_ids,:)];
    redundancy[CONNECTIONS_COUNT_FACES+1:CONNECTIONS_COUNT_FACES+8*N_CELLS_TOTAL] .= 1
    connectivities_phase_id[CONNECTIONS_COUNT_FACES+1:CONNECTIONS_COUNT_FACES+8*N_CELLS_TOTAL] .= phases[:BV]
    println("12. Body centers -> Vertices connections generated")

    # Step 13 => Generated the BF connections
    #=
    We already have exactly what we need:
        1. cell_faces_indices contain list of face ids that correspond to each cell. This is used to index node_id_face_centers
        2. cell_id repeated for N_FACES can be used to index body centers node ids.
    =#
    connectivities[CONNECTIONS_COUNT_FACES+8*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+14*N_CELLS_TOTAL, :] = [node_ids_body_centers[repeat(cell_id, inner=N_FACES)] node_ids_face_centers[cell_faces_indices]];
    redundancy[CONNECTIONS_COUNT_FACES+8*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+14*N_CELLS_TOTAL, :] .= 1
    connectivities_phase_id[CONNECTIONS_COUNT_FACES+8*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+14*N_CELLS_TOTAL, :] .= phases[:BF];

    println("13. Body center => Face center (BF) connections generated")
    #%% Step 14 -> Generate midnodes inside the body and Generate the BE connections.
    #=
    The steps involved are as follows:
        1. The edge centers associated with each cell can be obtained from cell_edges_indices. Every 12 corresponds to 1 cell.
        2. The midpoints for these data can be obtained => midnodes
        3. The connectivities are generated as B->M ; M -> E.

    =#
    # Step 14.1 => Obtain the body midnodes
    nodeCoords_body_midnodes = generate_node_coord([node_ids_body_centers[repeat(cell_id, inner=N_EDGES)] node_ids_edge_centers[cell_edges_indices]]', nodeCoords5);
    N_NODES6 = N_NODES5 + N_CELLS_TOTAL*N_EDGES;
    node_ids_body_midnodes = N_NODES5+1:N_NODES6;
    node_ids6 = [node_ids5; node_ids_body_midnodes];
    nodeCoords6 = [nodeCoords5 nodeCoords_body_midnodes];

    # Step 14.2 => Obtain the BE connections
    connectivities[CONNECTIONS_COUNT_FACES+14*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+26*N_CELLS_TOTAL, :] = [node_ids_body_centers[repeat(cell_id, inner=N_EDGES)] node_ids_body_midnodes];
    connectivities[CONNECTIONS_COUNT_FACES+26*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+38*N_CELLS_TOTAL, :] = [node_ids_body_midnodes node_ids_edge_centers[cell_edges_indices]];

    redundancy[CONNECTIONS_COUNT_FACES+14*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+38*N_CELLS_TOTAL] .= 1;
    connectivities_phase_id[CONNECTIONS_COUNT_FACES+14*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+38*N_CELLS_TOTAL] .= phases[:BE];
    println("14. Body center => body midnodes => Edge centers (BE) connections generated")

    # Obtaining FF connections
    #=
    The connections need to be generated as F-M-F. This raises 2 questions:
        1. What order do we choose faces?
        2. What order do we choose midnodes?

    The faces in each cell is taken in the following order:
        1. Back
        2. Front
        3. Left
        4. Right
        5. Bottom
        6. Top
    Better way is to to go clockwise about u, v, w in that order starting from back, left, bottom respectively:
        1,6
        6,2
        2,5
        5,1

        3,1
        1,4
        4,2
        2,3

        5,3
        3,6
        6,4
        4,5

    The starting points can be written as:
        1,6,2,5
        3,1,4,2
        5,3,6,4
    This can be rolled to left to get the end nodes.

    The midnodes are generated in order of the edges in the cell (using the edges_reverse_ids). Their order is as follows:
    edge_nodes =   [1 2; # parallel to u
                    4 3;
                    5 6;
                    8 7;
                    1 4; # parallel to v
                    5 8;
                    2 3;
                    6 7;
                    1 5; # parallel to w
                    4 8;
                    2 6;
                    3 7;]',
    The midnode corresponding to each FF connection is same as the index of the edge between two faces. Thus, the order of the edges(0:12) to be taken is:
        2,4,3,1
        5,7,8,6
        9,10,12,11

    Note that this is very much dependent on the way we've taken the edges. Modifying the edges should be followed by modifying the order here.
    =#
    # Following matrix is transposed. each row corresponds to column.
    ff_start_nodes_index = [1 6 2 5;
                            3 1 4 2;
                            5 3 6 4]';

    ff_end_nodes_index = circshift(ff_start_nodes_index, (-1,0));
    ff_mid_nodes_index =[2 4 3 1;
                        5 7 8 6;
                        9 10 12 11]';
    ff_start_nodes = reshape(node_ids_face_centers[cell_faces_indices], 6,:)[reshape(ff_start_nodes_index, :), :] |> i -> reshape(i, :);
    ff_end_nodes = reshape(node_ids_face_centers[cell_faces_indices], 6,:)[reshape(ff_end_nodes_index, :), :] |> i -> reshape(i, :);

    ff_mid_nodes = reshape(node_ids_body_midnodes, 12,:)[reshape(ff_mid_nodes_index, :), :] |> i -> reshape(i, :);

    connectivities[CONNECTIONS_COUNT_FACES+38*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+50*N_CELLS_TOTAL,:] = [ff_start_nodes ff_mid_nodes];
    connectivities[CONNECTIONS_COUNT_FACES+50*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+62*N_CELLS_TOTAL,:] = [ff_mid_nodes ff_end_nodes];

    redundancy[CONNECTIONS_COUNT_FACES+38*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+62*N_CELLS_TOTAL] .= 1
    connectivities_phase_id[CONNECTIONS_COUNT_FACES+38*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+62*N_CELLS_TOTAL] .= phases[:FF];

    println("15. Face centers => Body midnodes => Face centers (FF) connections are generated")
    println("*****Body connections are generated*****")
    nodeCoords = nodeCoords6;
    node_ids = node_ids6;

    # Generating connectivity cell id
    println("Generating connectivity cell id")
    phase_cell_connectivity = Dict();
    println("VE");
    phase_cell_connectivity[:VE] = [[repeat(cell_id, inner=N_EDGES) cell_edges_indices];
                                    [repeat(cell_id, inner=N_EDGES) cell_edges_indices.+N_EDGES_TOTAL]];

    println("FE");
    phase_cell_connectivity[:FE] = assign_cell_connections(N_EDGES_TOTAL*2+1, N_EDGES_TOTAL*2+N_FACES_TOTAL*4, cell_faces_map, node_ids_face_centers_repeated4.-N_NODES2);

    println("VF");
    phase_cell_connectivity[:VF] = assign_cell_connections(2*N_EDGES_TOTAL+4*N_FACES_TOTAL+1, N_EDGES_TOTAL*2+N_FACES_TOTAL*12, cell_faces_map, repeat(node_ids_face_centers_repeated4.-N_NODES2, outer=2));

    println("EE");
    phase_cell_connectivity[:EE] = assign_cell_connections(2*N_EDGES_TOTAL+12*N_FACES_TOTAL+1, N_EDGES_TOTAL*2+N_FACES_TOTAL*20, cell_faces_map, repeat(node_ids_face_centers_repeated4.-N_NODES2, outer=2));

    println("BV");
    phase_cell_connectivity[:BV] = [repeat(cell_id, inner=N_VERTICES) CONNECTIONS_COUNT_FACES+1:CONNECTIONS_COUNT_FACES+8*N_CELLS_TOTAL];

    println("BF");
    phase_cell_connectivity[:BF] = [repeat(cell_id, inner=N_FACES) CONNECTIONS_COUNT_FACES+8*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+14*N_CELLS_TOTAL];

    println("BE");
    phase_cell_connectivity[:BE] = [repeat(cell_id, inner=N_EDGES, outer=2) CONNECTIONS_COUNT_FACES+14*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+38*N_CELLS_TOTAL];

    println("FF");
    phase_cell_connectivity[:FF] = [repeat(cell_id, inner=N_EDGES, outer=2) CONNECTIONS_COUNT_FACES+38*N_CELLS_TOTAL+1:CONNECTIONS_COUNT_FACES+62*N_CELLS_TOTAL];

    println("*****Phase cell connectivity generated*****");

    #= Get the boundary nodes
    Boundary nodes. This can be achieved in a neat way.
        i) Nodes on edges should not be shared between more than 3 cells.
        ii) Nodes on Face should not be shared (only one cell it should belong to).
        iii) Nodes inside body are not boundary nodes.
    =#
    println("Finding the boundary nodes");
    boundary_node_ids = [];
    # append all the boundary nodes from corner nodes which where imported initially in the code. Both cell_faces_unique or cell_edges_unique can be used.
    append!(boundary_node_ids, reshape(cell_edges_unique[:, edge_redundancy .< 4],:) |> unique);
    # add all the edge centers corresponding to similar conditions.
    append!(boundary_node_ids, reshape(node_ids_edge_centers[edge_redundancy .< 4],:) |> unique);
    # add all the face centers corresponding to boundary faces
    append!(boundary_node_ids, node_ids_face_centers[face_redundancy .== 1]);
    # Each face contain 4 midnodes between F & V.
    append!(boundary_node_ids, node_ids_face_midnodes[repeat(face_redundancy.==1, inner=4)]);
    println("Received boundary nodes");
    boundary = falses(N_NODES6);
    boundary[boundary_node_ids] .= true;

    # Get element lengths
    # using searchsorted, which means that the phase ids are generated in ascending order. If not, used some other search method.
    lengths = zeros(N_PHASES);
    lengths2 = Dict();
    for phase in keys(phases)
        phase_id = phases[phase];
        el_nodes = nodeCoords[:, connectivities[searchsortedfirst(connectivities_phase_id, phase_id), :]];
        lengths[phase_id] = norm(diff(el_nodes, dims=2));
        lengths2[phase] = lengths[phase_id];
    end

    # Get the count of each phases
    phase_counts = Dict();
    for phase in keys(phases)
        phase_counts[phase] = count(==(1), phase_cell_connectivity[phase][:,1])
    end

    Vᵤ = find_Vᵤ(cell_vertice_ids[:,1], nodeCoords, gmsh_hexahedron.edge_nodes);

    cell_connectivity = vcat(values(phase_cell_connectivity)...);

    return nodeCoords, node_ids, cell_id, connectivities, cell_connectivity, phases, phase_counts, lengths, redundancy, boundary, connectivities_phase_id, Vᵤ
end

function trans_matrix(t)
    tol = 1e-8;
    x = [1.,0,0];
    n2 = x×t;
    if (norm(n2) < tol)
        n2 = [0.,0,1];
    end
    normalize!(n2);
    n1 = n2×t;
    normalize!(n1);
    A = [t n1 n2]';
    t_matrix = spzeros(12,12);
    for i in 1:3:12
        t_matrix[i:i+2, i:i+2] = A;
    end
    return t_matrix
end

function generate_t_matrices(nodeCoords, connectivities)
    t_matrices = Dict();
    tangents = [];
    println("Started generating tangents");
    for connection_id in 1:size(connectivities,1)
        coords = nodeCoords[:, connectivities[connection_id, :]];
        t = coords[:,2]-coords[:,1];
        normalize!(t);
        t = round.(t, digits=6);
        push!(tangents, t);
        if t ∉ keys(t_matrices)
            t_matrices[t] = trans_matrix(t);
        end
    end
    println("Generated tangents");
    return t_matrices, tangents
end

end
